/*
3体問題のアニメーション

直前の状態から次の状態が決まるアニメーションのサンプル
*/
module Main;

import Canim;
import Canim.Machine;
import Cairo;
import Math;
import MiscAlgos.Geometry;

// FPS
c_fps : F64;
c_fps = 60.0;

// 画面サイズ
c_image_size : (I64, I64);
c_image_size = (800, 600);

// 重力定数
gravity : F64;
gravity = 20.0;

// 天体の状態
type Body = struct {
    pos : Vec2,
    vel : Vec2,
    mass : F64,
};

// アニメーションの状態
type State = Array Body;

namespace State {
    // 初期状態
    initial : State;
    initial = [
        Body {
            pos : Vec2::make(100.0, 0.0),
            vel : Vec2::make(0.0, 20.0),
            mass : 100.0,
        },
        Body {
            pos : Vec2::make(100.0, 0.0).rotated(2.0 * pi64 / 3.0),
            vel : Vec2::make(0.0, 20.0).rotated(2.0 * pi64 / 3.0),
            mass : 100.0,
        },
        Body {
            pos : Vec2::make(100.0, 0.0).rotated(4.0 * pi64 / 3.0),
            vel : Vec2::make(0.0, 20.0).rotated(4.0 * pi64 / 3.0),
            mass : 100.0,
        },
    ];

    // 状態を更新する
    update : TimeDelta -> State -> State;
    update = |dt, state| (
        range(0, 3).fold([], |i, new_state|
            // 天体のリストを、位置を更新するべき天体と、その他に分ける
            let this = state.@(i);
            let others = range(0, 3).filter(|j| j != i).map(|j| state.@(j));
            
            // thisが受ける力を計算
            let force = others.fold(Vec2::make(0.0, 0.0), |other, force|
                let r = other.@pos - this.@pos;
                let d = r.get_length;
                let f = r.scaled(1.0 / (d * d * d)).scaled(this.@mass * other.@mass * gravity);
                force + f
            );

            // thisの加速度、速度、位置を更新
            let acc = force;
            let vel = this.@vel + acc.scaled(dt);
            let pos = this.@pos + vel.scaled(dt);

            // 新しい状態を追加
            new_state.push_back(Body {
                pos : pos,
                vel : vel,
                mass : this.@mass,
            })
        )
    );

    // 状態を描画する
    render : State -> Cairo -> IO ();
    render = |state, cairo| (
        cairo.set_source_rgb((1.0, 1.0, 1.0));;
        state.to_iter.fold_m((), |body, _|
            cairo.new_sub_path;;
            cairo.arc(body.@pos.to_tuple, 5.0, 0.0, 2.0 * pi64)
        );;
        cairo.fill
    );
}

main : IO ();
main = (
    let config = Canim::Config {
        fps : c_fps,
        window_size : c_image_size,
    };
    let state = Machine::from_transit(
        State::initial,
        |dt, s| let s = s.update(dt); (s, s)
    );
    let ani = state.map(State::render);
    ani.run(config)
);