// 状態機械ライブラリ
// 
//
module Canim.Machine;

// i型の入力を受け取るとo型の値を返す状態機械
type Machine i o = struct {
    _run : i -> IO (Machine i o, o),
};

impl Machine i : Functor {
    map = |f, machine| (
        Machine {
            _run : |i| (
                let (machine, o) = *machine.run(i);
                pure $ (machine.map(f), f(o))
            )
        }
    );
}

namespace Machine {
    // 状態機械を1ステップ進める
    run : i -> Machine i o -> IO (Machine i o, o);
    run = |i, machine| (
        let (machine, o) = *(machine.@_run)(i);
        pure $ (machine, o)
    );

    // 初期状態と状態遷移関数からオブジェクトを作成する
    from_transit : s -> (i -> s -> (s, o)) -> Machine i o;
    from_transit = |state, update| (
        Machine {
            _run : |i| (
                let (state, o) = update(i, state);
                pure $ (from_transit(state, update), o)
            )
        }
    );

    // 入力されたものをそのまま出力する状態機械を作成する
    identity : Machine i i;
    identity = from_transit((), |i, _| ((), i));

    // 入力の累積和を計算する状態機械を作成する
    // 
    // 最初の出力は0で、以降は直前までの入力の累積和を出力する
    integrate : [o : Additive] Machine o o;
    integrate = from_transit(zero, |i, sum| (sum + i, sum));
}

test_machine : [o : Eq, o : ToString] Machine i o -> Array (i, o) -> IO ();
test_machine = |machine, ios| (
    ios.to_iter.fold_m(machine, |(i, o), machine|
        let (machine, o1) = *machine.run(i);
        assert_eq(|_|"Test Fail", o1, o);;
        pure $ machine
    ).forget
);

test : IO ();
test = (
    let machine = Machine::integrate;
    let input = [1, 2, 3, 4, 5];
    let output = [0, 1, 3, 6, 10];
    let ios = input.to_iter.zip(output.to_iter).to_array;
    test_machine(machine, ios);;
    pure()
);