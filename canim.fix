module Canim;

import Cairo;
import Cairo.XlibSurface;
import Cairo.ImageSurface;
import Time hiding {Time};
import MiscAlgos.Geometry;
import MiscAlgos.Functional;

import Canim.Machine;

type TimeDelta = F64;
type Time = F64;

// 現在時刻を出力する状態機械
clock : Machine TimeDelta Time;
clock = Machine::integrate;

// 描画処理の型
type Draw = Cairo -> IO ();

namespace Draw {
    // 描画位置を平行移動する
    translate : Vec2 -> Draw -> Draw;
    translate = |vec, draw, cairo| (
        let org_matrix = *cairo.get_matrix;
        cairo.translate(vec.to_tuple);;
        // TODO: use cairo.save and cairo.restore
        draw(cairo);;
        cairo.set_matrix(org_matrix);;
        pure()
    );
}

// アニメーションを表す型
type Animation = Machine TimeDelta Draw;

namespace Animation {
    // バッファに描画するアニメーションを作成する
    //
    // 第一引数はバッファリングする矩形
    buffered : Rectangle -> Animation -> Animation;
    buffered = |rect, ani| Machine::from_transition_io((ani, none()), |dt, (ani, opt_buffer)|
        // バッファとそれに描画を行うためのコンテキストを取得する
        // TODO: このままだと変換行列がスケールされている時にバッファの解像度が落ちたり過度に高くなったりするので対処する。cairo_user_to_deviceとかを使うとできるはず。
        let (surface, cairo, draw_buf) = *match opt_buffer {
            none() => ( // 未生成のとき
                // バッファとそれに描画を行うためのコンテキストを作成する
                let surface = *ImageSurface::create(Format::argb, rect.@size.to_tuple.map01(to_I32));
                let cairo = *Cairo::create(surface);

                // さらに、そのバッファを描画するという内容の描画処理を作成する
                let draw_buf = |cairo| (
                    cairo.set_source_surface(surface, rect.@pos.to_tuple);;
                    cairo.rectangle(rect.@pos.to_tuple, rect.@size.to_tuple);;
                    cairo.fill
                );
                pure $ (surface, cairo, draw_buf)
            ),
            some(buffer_data) => pure $ buffer_data
        };

        // 描画命令を取得し、バッファに描画を行う
        let (ani, draw) = *ani.run(dt);
        (draw.translate(-rect.@pos))(cairo);;

        pure $ ((ani, some $ (surface, cairo, draw_buf)), draw_buf)
    );
}

// アニメーションの設定
type Config = box struct {
    // 画面のサイズ
    window_size : (I64, I64),
    // 期待するフレームレート
    fps : F64,
};

namespace Animation {
    // ウィンドウを作成し、アニメーションを実行する
    run_ani : Config -> Animation -> IO ();
    run_ani = |config, ani| (
        // ウィンドウとCairoコンテキストの作成
        let window = *XlibSurface::create_simple_window(config.@window_size);
        let event_mask = EventMask::key_press;
        window.select_input(event_mask);;
        let surface = *XlibSurface::create_back_surface(window);
        let cairo = *Cairo::create(surface);

        // メインループ
        let start_time = (*Time::get_now_monotonic).to_F64;
        loop_m((start_time, ani), |(prev_time, ani)|
            // 前回からの経過時間が1フレーム以内なら、処理をスキップ
            let time = (*Time::get_now_monotonic).to_F64;
            let time_delta = time - prev_time;
            if time_delta < 1.0 / config.@fps { continue_m $ (prev_time, ani) };

            // FPSを表示する
            println("FPS: " + (1.0 / time_delta).to_string);;

            // Xイベントによって状態を更新する処理
            // 現状：Qキーが押されたら終了
            let exit = *loop_m((), |_| (
                if *window.events_queued(QueuedMode::already) == 0 { break_m $ false };
                let event = *window.next_event;

                let exit = *(
                    if !event.is_key_press { pure $ false };
                    let keycode = event.as_key_press.@keycode;
                    let keysym = *window.keycode_to_keysym(keycode);
                    let keysym_q = string_to_keysym("q");
                    pure $ keysym == keysym_q
                );
                if exit { break_m $ true };

                continue_m $ ()
            ));

            // Qキーが押されていた場合はメインループを終了する
            if exit { break_m $ () };

            // アニメーションを進める
            let (ani, draw) = *ani.run(time_delta);

            // フレームを描画する
            // 画面の中心を描画命令の原点にする
            let window_center = Vec2::make_from_tuple $ config.@window_size.map01(|x| x.to_F64 * 0.5);
            (draw.translate(window_center))(cairo);;

            // 描画結果を画面に表示
            window.flush;;
            window.swap_buffers(XbeSwapAction::background);;

            continue_m $ (time, ani)
        );;

        window.destroy_window;;

        pure()
    );
}