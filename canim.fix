module Canim;

import Cairo;
import Cairo.XlibSurface;
import Cairo.ImageSurface;
import Time hiding {Time};
import MiscAlgos.Geometry;
import MiscAlgos.Functional;

import Canim.Machine;

type TimeDelta = F64;
type Time = F64;

// 現在時刻を出力する状態機械
clock : Machine TimeDelta Time;
clock = Machine::integrate;

// 描画処理の型
type Draw = Cairo -> IO ();

namespace Draw {
    // 描画命令終了後にcairoのtransformをリセットするようにする
    restore_transform : Draw -> Draw;
    restore_transform = |draw, cairo| (
        let org_matrix = *cairo.get_matrix;
        draw(cairo);;
        cairo.set_matrix(org_matrix);;
        pure()
    );

    // 描画位置を平行移動する
    translate : Vec2 -> Draw -> Draw;
    translate = |vec, draw, cairo| (
        let org_matrix = *cairo.get_matrix;
        cairo.translate(vec.to_tuple);;
        draw(cairo);;
        cairo.set_matrix(org_matrix);;
        pure()
    );
}

// アニメーションを表す型
type Animation = Machine TimeDelta Draw;

namespace Animation {
    // バッファに描画するアニメーションを作成する
    //
    // 第一引数はバッファリングする矩形
    buffered : Rectangle -> Animation -> Animation;
    buffered = |rect, ani| Machine::from_transition_io(none(), |dt, opt_buffer|
        // 描画命令を取得する
        let (ani, draw) = *ani.Machine::run(dt);

        // バッファとそれに描画を行うためのコンテキストを取得する
        let (surface, cairo, draw_buf) = *match opt_buffer {
            none() => ( // 未生成のとき
                // バッファとそれに描画を行うためのコンテキストを作成する
                let surface = *ImageSurface::create(Format::argb, rect.@size.to_tuple.map01(to_I32));
                let cairo = *Cairo::create(surface);

                // さらに、そのバッファを描画するという内容の描画処理を作成する
                let draw_buf = |cairo| (
                    cairo.set_source_surface(surface, (0.0, 0.0));;
                    cairo.rectangle((0.0, 0.0), rect.@size.to_tuple.map01(to_F64));;
                    cairo.fill
                );
                pure $ (surface, cairo, draw_buf)
            ),
            some(buffer_data) => pure $ buffer_data
        };

        // バッファに描画を行う
        (draw.translate(rect.@pos))(cairo);;

        pure $ (some $ (surface, cairo, draw_buf), draw_buf)
    );
}

// アニメーションの設定
type Config = box struct {
    // 画面のサイズ
    window_size : (I64, I64),
    // 期待するフレームレート
    fps : F64,
};

namespace Frame {
    // ウィンドウを作成し、アニメーションを実行する
    run : Config -> Animation -> IO ();
    run = |config, ani| (
        // ウィンドウとCairoコンテキストの作成
        let window = *XlibSurface::create_simple_window(config.@window_size);
        let event_mask = EventMask::key_press;
        window.select_input(event_mask);;
        let surface = *XlibSurface::create_back_surface(window);
        let cairo = *Cairo::create(surface);

        // メインループ
        let start_time = (*Time::get_now_monotonic).to_F64;
        loop_m((start_time, ani), |(prev_time, ani)|
            // 前回からの経過時間が1フレーム以内なら、処理をスキップ
            let time = (*Time::get_now_monotonic).to_F64;
            let time_delta = time - prev_time;
            if time_delta < 1.0 / config.@fps { continue_m $ (prev_time, ani) };

            // FPSを表示する
            println("FPS: " + (1.0 / time_delta).to_string);;

            // Xイベントによって状態を更新する処理
            // 現状：Qキーが押されたら終了
            let exit = *loop_m((), |_| (
                if *window.events_queued(QueuedMode::already) == 0 { break_m $ false };
                let event = *window.next_event;

                let exit = *(
                    if !event.is_key_press { pure $ false };
                    let keycode = event.as_key_press.@keycode;
                    let keysym = *window.keycode_to_keysym(keycode);
                    let keysym_q = string_to_keysym("q");
                    pure $ keysym == keysym_q
                );
                if exit { break_m $ true };

                continue_m $ ()
            ));

            // Qキーが押されていた場合はメインループを終了する
            if exit { break_m $ () };

            // アニメーションを進める
            let (ani, draw) = *ani.Machine::run(time_delta);

            // フレームを描画する
            // 画面の中心を描画命令の原点にする
            let window_center = Vec2::make_from_tuple $ config.@window_size.map01(|x| x.to_F64 * 0.5);
            (draw.translate(window_center))(cairo);;

            // 描画結果を画面に表示
            window.flush;;
            window.swap_buffers(XbeSwapAction::background);;

            continue_m $ (time, ani)
        );;

        window.destroy_window;;

        pure()
    );
}