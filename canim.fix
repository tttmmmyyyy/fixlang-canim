module Canim;

import Cairo;
import Cairo.XlibSurface;
import Time hiding {Time};
import MiscAlgos.Geometry;
import MiscAlgos.Functional;

type TimeDelta = F64;
type Time = F64;

// 時間軸上の点を表す構造体
type Tick = struct {
    // 時刻
    time : Time,
    // 前回のフレームからの経過時間
    time_delta : TimeDelta
};

// 時間とともに変化する値を表す構造体
type Stream s = struct {
    // 現在の値
    value : s,
    // 次の値を計算する関数
    update : Tick -> IO (Stream s),
};

impl Stream : Functor {
    map = |f, stream| (
        Stream {
            value : f(stream.@value),
            update : |tick| (
                let next = *(stream.@update)(tick);
                pure $ next.map(f)
            )
        }
    );
}

namespace Stream {
    // 現在時刻を表すストリーム
    time : Stream Time;
    time = iterate(0.0, |tick, _| pure $ tick.@time);

    // 状態遷移関数からストリームを作成する
    iterate : s -> (Tick -> s -> IO s) -> Stream s;
    iterate = |initial, update| (
        Stream {
            value : initial,
            update : |tick| (
                let state = *update(tick, initial);
                pure $ iterate(state, update)
            )
        }
    );
}

// 描画処理を表す型
type Draw = Cairo -> IO ();

// アニメーションを表す型
type Animation = Stream Draw;

// アニメーションの設定
type Config = box struct {
    // 画面のサイズ
    window_size : (I64, I64),
    // 期待するフレームレート
    fps : F64,
};

namespace Frame {
    // ウィンドウを作成し、アニメーションを実行する
    run : Config -> Animation -> IO ();
    run = |config, ani| (
        // ウィンドウとCairoコンテキストの作成
        let window = *XlibSurface::create_simple_window(config.@window_size);
        let event_mask = EventMask::key_press;
        window.select_input(event_mask);;
        let surface = *XlibSurface::create_back_surface(window);
        let cairo = *Cairo::create(surface);

        // メインループ
        let start_time = (*Time::get_now_monotonic).to_F64;
        loop_m((start_time, ani), |(prev_time, ani)|
            // 前回からの経過時間が1フレーム以内なら、状態を更新しない。
            let time = (*Time::get_now_monotonic).to_F64;
            let time_delta = time - prev_time;
            if time_delta < 1.0 / config.@fps { continue_m $ (prev_time, ani) };

            // FPSを表示する
            println("FPS: " + (1.0 / time_delta).to_string);;

            // Xイベントによって状態を更新する処理
            // 現状：Qキーが押されたら終了
            let exit = *loop_m((), |_| (
                if *window.events_queued(QueuedMode::already) == 0 { break_m $ false };
                let event = *window.next_event;

                let exit = *(
                    if !event.is_key_press { pure $ false };
                    let keycode = event.as_key_press.@keycode;
                    let keysym = *window.keycode_to_keysym(keycode);
                    let keysym_q = string_to_keysym("q");
                    pure $ keysym == keysym_q
                );
                if exit { break_m $ true };

                continue_m $ ()
            ));

            // Qキーが押されていた場合はメインループを終了する
            if exit { break_m $ () };

            // アニメーションを描画する
            // ユーザ空間の中心を画面の中心に移動する
            let org_matrix = *cairo.get_matrix;
            let window_center = config.@window_size.map01(|x| x.to_F64 * 0.5);
            cairo.translate(window_center);;
            (ani.@value)(cairo);;
            cairo.set_matrix(org_matrix);;

            // 描画結果を画面に表示
            window.flush;;
            window.swap_buffers(XbeSwapAction::background);;

            // アニメーションを更新する
            let tick = Tick { time : time - start_time, time_delta : time_delta };
            let ani = *(ani.@update)(tick);

            continue_m $ (time, ani)
        );;

        window.destroy_window;;

        pure()
    );
}